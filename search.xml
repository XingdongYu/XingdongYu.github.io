<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通过Sketch创建一个Flutter应用（译）]]></title>
    <url>%2F2020%2F11%2F11%2Fflutter-from-sketch%2F</url>
    <content type="text"><![CDATA[想象一下，如果我们可以通过Sketch创建的设计文件来创建一个可正常使用的Flutter应用，是不是屌爆了？先让我们验证一下。计划如下：Sketch将其设计文档另存为zip存档，这些归档文件包含多个JSON文件，这些文件描述一些元数据、编辑器的状态、页面和画板以及构成设计的所有图形元素。我们浏览zip的文件结构以查找画板，提取相关数据，然后在Flutter画布上绘制每个图形元素。然后，可以使用画板之间的链接在Flutter中切换界面。还有voilá(啥？)——即时应用程序。 谷歌了几分钟后没有找到格式描述，因此这也是一次对Sketch文件格式进行逆向工程的练习。 分析文件格式在Sketch中创建以下示例：另存为example.sketch。有一页包含两个画板，这些画板具有通常在iOS上找到的状态栏和标题栏，并且包含一些文本和一些矩形。为了绘制后退按钮，我使用了一个向量。如前所述，.sketch文件是zip归档文件： 12$ file example.sketch example.sketch: Zip archive data, at least v2.0 to extract 它包含以下文件：1234567891011$ unzip -l example.sketch Archive: example.sketch Length Name--------- ---- 664 document.json 32797 pages/E025DB91-38B6-4AE4-BACB-647DF4A40CBA.json 137 user.json 696 meta.json 28858 previews/preview.png--------- ------- 63152 5 files 让我们忽略预览图像。 user.json文件似乎处于编辑器的状态。我会忽略它。 document.json文件也不包含有用的信息-但由于它包含一个空资产集合，因此对于“真实世界”草图文件而言可能很重要，该文件除了简单的矩形和文本外还包含位图图像，符号或其他元素。但我暂时将其忽略。 meta.json文件更加有趣。它包含有关用于创建.sketch文件（我将忽略）的Sketch应用程序的信息，以及以下目录：1234567891011121314151617&#123; &quot;commit&quot;: &quot;399b83655ed261b257875cf8e762efa1a649509e&quot;, &quot;pagesAndArtboards&quot;: &#123; &quot;E025DB91-38B6-4AE4-BACB-647DF4A40CBA&quot;: &#123; &quot;name&quot;: &quot;Page 1&quot;, &quot;artboards&quot;: &#123; &quot;8C823950-BF56-42E2-ACAE-3762BBC8A570&quot;: &#123; &quot;name&quot;: &quot;First&quot; &#125;, &quot;49F995AB-4992-42AB-B708-86C5C42B3CDB&quot;: &#123; &quot;name&quot;: &quot;Second&quot; &#125; &#125; &#125; &#125;, ...&#125; 我将使用此信息来加载包含特定画板的页面文件。我什至可以按需加载这些文件。查看页面对象的JSON文件，我可以猜出用于表示数据的类在实例化为JSON之前的样子。大多数JSON对象都包含一个带有类名的_class属性和一个do_objectID属性，该属性似乎是标识该实例的UUID。没有标识符的对象可能是结构而不是类。1234567891011121314151617181920212223242526272829&#123; &quot;_class&quot;: &quot;page&quot;, &quot;do_objectID&quot;: &quot;E025DB91-38B6-4AE4-BACB-647DF4A40CBA&quot;, ... &quot;frame&quot;: &#123; &quot;_class&quot;: &quot;rect&quot;, &quot;constrainProportions&quot;: false, &quot;height&quot;: 0, &quot;width&quot;: 0, &quot;x&quot;: 0, &quot;y&quot;: 0 &#125;, ... &quot;name&quot;: &quot;Page 1&quot;, ... &quot;style&quot;: &#123; &quot;_class&quot;: &quot;style&quot;, ... &#125;, &quot;layers&quot;: [ &#123; &quot;_class&quot;: &quot;artboard&quot;, &quot;do_objectID&quot;: &quot;49F995AB-4992-42AB-B708-86C5C42B3CDB&quot;, ... &#125;, ... ], ...&#125; 幸运的是，整个结构似乎很统一。每个元素都有一个名称，一个框架，某些样式和一些图层，这些图层是子元素的列表。其他属性对我来说不太重要。 在Dart中解码Sketch文件掌握了有关文件结构的知识之后，我将创建类来表示Dart中的那些元素。然后，这应该有助于将元素绘制到Flutter画布中，创建一个SketchWidget来显示此类画布，并最终实现这些小部件之间的导航。感谢压缩包，阅读zip压缩包很容易。 阅读目录让我们使用以下Dart程序对此进行测试： 12345678910import 'dart:io';import 'package:archive/archive.dart';void main() &#123; final file = File('example.sketch'); final bytes = file.readAsBytesSync(); final archive = ZipDecoder().decodeBytes(bytes); for (final file in archive) &#123; print(file.name); &#125;&#125; 打印的应该是上面显示的文件名。 下一步是使用findFile从档案中提取meta.json文件，并将其解码为JSON文档，然后将其打印出来，以确保它也起作用： 1234567891011import 'dart:convert';import 'dart:io';import 'package:archive/archive.dart';void main() &#123; final file = File('example.sketch'); final bytes = file.readAsBytesSync(); final archive = ZipDecoder().decodeBytes(bytes); final content = archive.findFile('meta.json').content; final data = json.decode(utf8.decode(content)); print(JsonEncoder.withIndent(' ').convert(data));&#125; 这将生成上面显示的数据结构。 如果您遵循自己的Sketch文件，则期望UUID有所不同。仍然应该有一个pagesAndArtboards属性，该属性至少列出一个包含零个或多个画板的页面。 提取画板为了提取画板，我创建了一个抽象的Element类，其中Artboard（以及Page和以后的所有其他图形元素）是该类的子类。我决定使用计算字段（也称为getter方法）访问所有信息，而不是将所有内容存储在实例变量中。这可能效率较低，但编写的代码也较少： 123456789abstract class Element &#123; Element(this.data); final Map data; String get name =&gt; data['name']; String get clazz =&gt; data['_class']; String get id =&gt; data['do_objectID']; Iterable&lt;Element&gt; get layers =&gt; (data['layers'] as List).map((child) =&gt; Element.create(child)); ... 要创建具体的元素子类，我使用静态的Element.create方法。它需要知道从Sketch类名称到Dart类的每个映射（我使用clazz是因为class是Dart中的保留关键字）： 12345678910111213 ... static Element create(Map data) &#123; final clazz = data['_class']; switch (clazz) &#123; case 'artboard': return Artboard(data); case 'page': return Page(data); default: throw 'Unknown element class $clazz'; &#125; &#125;&#125; 这是前两个元素子类： 1234567class Artboard extends Element &#123; Artboard(Map data) : super(data);&#125;class Page extends Element &#123; Page(Map data) : super(data); Iterable&lt;Artboard&gt; get artboards =&gt; layers.whereType&lt;Artboard&gt;();&#125; 为了方便起见，我还向Page添加了画板getter方法。 读取.sketch文件并提供对所有画板的访问权限的任务由此File类执行。为了避免名称冲突，我将所有类放入一个新的sketch.dart包中，该包将以名称前缀sk导入。 1234567891011121314151617181920class File &#123; final Map&lt;String, Artboard&gt; artboards = &#123;&#125;; File(List&lt;int&gt; bytes) &#123; final archive = ZipDecoder().decodeBytes(bytes); final content = archive.findFile('meta.json').content; final data = json.decode(utf8.decode(content)); Map paa = data['pagesAndArtboards']; for (final k1 in paa.keys) &#123; final content = archive.findFile('pages/$k1.json').content; final data = json.decode(utf8.decode(content)); final page = Page(data); for (final artboard in page.artboards) &#123; artboards[artboard.name] = artboard; &#125; &#125; &#125; static Future&lt;File&gt; named(String name) async &#123; return File(await io.File(name).readAsBytes()); &#125;&#125; 主函数： 1234567import 'dart:convert';import 'package:sketch_flutter/sketch.dart' as sk;void main() async &#123; final file = await sk.File.named('example.sketch'); final a = file.artboards['First']; print(JsonEncoder.withIndent(' ').convert(a.data));&#125; 它应该打印与以前相同的数据结构。但是现在一切都很好地封装了。 绘图元素我可以并且应该使我的代码独立于Flutter。但是，我必须为常见概念（如Rect，Color或Sketch使用的属性字符串）创建自己的类，然后定义帮助程序方法以将其转换为Flutter（resp.dart：ui）等效项。因为这是一个概念证明，所以我将使它依赖Flutter，因为那样我不必创建ElementVisitor和其他抽象来分离问题。 缺少元素查看JSON输出，我的画板包含矩形，文本，组和shapPath类。让我们定义子类（此处未显示）并将其添加到Element.create： 1234567891011121314151617181920static Element create(Map data) &#123; final clazz = data['_class']; switch (clazz) &#123; case 'artboard': return Artboard(data); case 'group': return Group(data); case 'rectangle': return Rectangle(data); case 'page': return Page(data); case 'shapePath': return ShapePath(data); case 'text': return Text(data); default: throw 'Unknown element class $clazz'; &#125; &#125;&#125; 由于所有元素都有框架，因此我们可以使用它在画布上绘制矩形，以了解有关Sketch坐标的更多信息。 设计草图这是设置Flutter应用程序的常用样板代码： 1234567891011import 'package:flutter/material.dart';import 'sketch.dart' as sk;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: SketchPage(), ); &#125;&#125; SketchPage小部件从应用程序的资源加载我的示例（不应对其进行硬编码），并使用CustomPaint小部件绘制第一个画板。 1234567891011121314151617181920212223242526class SketchPage extends StatelessWidget &#123; Future&lt;sk.Artboard&gt; _loadArtboard(BuildContext context) &#123; final bundle = DefaultAssetBundle.of(context); return bundle.load('example.sketch').then((asset) &#123; final bytes = asset.buffer.asUint8List(); return sk.File(bytes).artboards['First']; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: FutureBuilder&lt;sk.Artboard&gt;( future: _loadArtboard(context), builder: (context, snapshot) &#123; if (snapshot.hasError) return Text('$&#123;snapshot.error&#125;'); if (!snapshot.hasData) return CircularProgressIndicator(); final artboard = snapshot.data; return CustomPaint( size: artboard.frame.size, painter: ArtboardPainter(artboard), ); &#125;, ), ); &#125;&#125; 当然，最重要的类是ArtboardPainter。它将为每个元素绘制矩形，然后递归下降： 12345678910111213141516171819class ArtboardPainter extends CustomPainter &#123; final sk.Artboard artboard; ArtboardPainter(this.artboard); @override void paint(Canvas canvas, Size size) &#123; _draw(artboard, canvas); &#125; void _draw(sk.Element e, Canvas canvas) &#123; final p = Paint() ..color = Colors.black ..style = PaintingStyle.stroke; canvas.drawRect(e.frame, p); for (final c in e.layers) _draw(c, canvas); &#125; @override bool shouldRepaint(CustomPainter oldDelegate) &#123; return true; &#125;&#125; 当然，我必须在Element中实现框架。我还注意到，我的图层可以为空，因此我不得不稍微更改该访问器： 123456789101112131415abstract class Element &#123; ... ui.Rect get frame &#123; final frame = data['frame']; assert(frame['_class'] == 'rect'); return ui.Rect.fromLTWH( frame['x'].toDouble(), frame['y'].toDouble(), frame['width'].toDouble(), frame['height'].toDouble(), ); &#125; Iterable&lt;Element&gt; get layers =&gt; (data['layers'] as List)? .map((child) =&gt; Element.create(child)) ?? []; ... 结果还不错： 子元素似乎具有相对坐标系（这是明智的设计决策）。我还注意到画板的框架表示页面上的位置，这是我所不希望的，因此我将重写画板的getter方法，如下所示： 12345class Artboard extends Element &#123; ... @override ui.Rect get frame =&gt; ui.Offset.zero &amp; super.frame.size;&#125; 然后，在应用递归之前先转换坐标系: 12345678910111213class ArtboardPainter extends CustomPainter &#123; ... void _draw(sk.Element e, Canvas canvas) &#123; final p = Paint() ..color = Colors.black ..style = PaintingStyle.stroke; canvas.drawRect(e.frame, p); canvas.save(); canvas.translate(e.frame.left, e.frame.top); for (final c in e.layers) _draw(c, canvas); canvas.restore(); &#125; ... 现在看上去有点feel了： 顺便说一句，我选择了一个与画板大小相同的模拟器来最大程度地减少问题。我实际上使用了Sketch支持的调整大小提示，但是出于概念验证的目的，我不会尝试实现它们。我假设Sketch使用与macOS分别由iOS实现的相同的自动调整大小算法。 添加颜色黑色的笔触很无聊。让我们添加颜色。深入JSON，似乎style属性具有borders和fill属性，这是border或fill对象的列表，其对象的color属性为RGBA值。 这是代表这些样式的代码： 123456789101112131415161718192021222324252627282930class Border &#123; final Map data; Border(this.data) : assert(data['_class'] == 'border'); bool get isEnabled =&gt; data['isEnabled']; ui.Color get color =&gt; Style._createColor(data['color']); double get thickness =&gt; data['thickness'].toDouble();&#125;class Fill &#123; final Map data; Fill(this.data) : assert(data['_class'] == 'fill'); bool get isEnabled =&gt; data['isEnabled']; ui.Color get color =&gt; Style._createColor(data['color']);&#125;class Style &#123; final Map data; Style(this.data) : assert(data['_class'] == 'style'); List&lt;Border&gt; get borders =&gt; (data['borders'] as List)? .map((b) =&gt; Border(b))?.where((b) =&gt; b.isEnabled) ?? []; Iterable&lt;Fill&gt; get fills =&gt; (data['fills'] as List)? .map((f) =&gt; Fill(f))?.where((f) =&gt; f.isEnabled) ?? []; static ui.Color _createColor(Map data) &#123; assert(data['_class'] == 'color'); return ui.Color.fromARGB( (255 * data['alpha'].toDouble()).round(), (255 * data['red'].toDouble()).round(), (255 * data['green'].toDouble()).round(), (255 * data['blue'].toDouble()).round(), ); &#125;&#125; 然后，我向Element添加样式get方法： 123abstract class Element &#123; ... Style get style =&gt; Style(data['style']); 接下来，我重构ArtboardPainter渲染元素的方式。通过添加如下所示的render方法，可以将其委托给Element，而不是执行该类中的所有操作： 1234567891011121314...void render(ui.Canvas canvas) &#123; final p = ui.Paint() ..color = ui.Color(0xFF000000) ..style = ui.PaintingStyle.stroke; canvas.drawRect(frame, p); renderChildren(canvas);&#125;void renderChildren(ui.Canvas canvas) &#123; canvas.save(); canvas.translate(frame.left, frame.top); for (final c in layers) c.render(canvas); canvas.restore();&#125; 这大大简化了ArtboardPainter类： 123456789101112class ArtboardPainter extends CustomPainter &#123; final sk.Artboard artboard; ArtboardPainter(this.artboard); @override void paint(Canvas canvas, Size size) &#123; artboard.render(canvas); &#125; @override bool shouldRepaint(ArtboardPainter oldDelegate) &#123; return oldDelegate.artboard != artboard; &#125;&#125; 然后，我为Rectangle覆盖渲染以最终添加颜色： 12345678910class Rectangle extends Element &#123; Rectangle(Map data) : super(data); @override void render(ui.Canvas canvas) &#123; if (style.fills.isNotEmpty) &#123; final color = style.fills.first.color; canvas.drawRect(frame, ui.Paint()..color = color); &#125; &#125;&#125; 现在，画板应如下所示: 显示文字接下来显示文本。同样，我通过查看JSON来猜测结构。 Text元素的样式带有textStyle属性，可以将其封装为Flutter TextStyle类。但是，我不认为我需要使用它。相反，我要查看的是attributedString属性，我需要将其转换为Flutter TextSpan。归因字符串包含描述字体系列，字体大小和颜色的字符串属性（除了其他我将忽略的属性）。相反，我将始终将文本居中。 下面的代码有点怪异，我尝试实现一些最低要求，以便在屏幕上获取一些文本，并使用一些快捷方式。不幸的是，我不仅要向dart：ui添加依赖，还必须向flutter / widgets.dart添加依赖，因为我需要TextSpan和TextStyle。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Text extends Element &#123; Text(Map data) : super(data); TextSpan get text &#123; final str = data['attributedString']; assert(str['_class'] == 'attributedString'); final string = str['string'] as String; final spans = &lt;TextSpan&gt;[]; for (Map a in str['attributes']) &#123; assert(a['_class'] == 'stringAttribute'); int location = a['location'].toInt(); int length = a['length'].toInt(); final text = string.substring(location, location + length); final aa = a['attributes']; final fa = aa['MSAttributedStringFontAttribute']; final fn = fa != null ? fa['attributes']['name'].toString() : null; final fs = fa != null ? fa['attributes']['size'].toDouble() : null; final ca = aa['MSAttributedStringColorAttribute']; final style = TextStyle( fontFamily: fn != null ? _fontFamilyMapping[fn] ?? fn : null, fontWeight: _fontWeightMapping[fn], fontSize: fs, color: ca != null ? Style._createColor(ca) : null, ); spans.add(TextSpan( text: text, style: style, )); &#125; if (spans.isEmpty) return TextSpan(text: ''); if (spans.length == 1) return spans.first; return TextSpan(children: spans); &#125; @override void render(ui.Canvas canvas) &#123; final p = TextPainter( text: text, textDirection: TextDirection.ltr, textAlign: TextAlign.center, ); final f = frame; p.layout(maxWidth: f.width); p.paint( canvas, Offset( f.left + (f.width - p.size.width) / 2, f.top + (f.height - p.size.height) / 2, ), ); &#125; static const _fontFamilyMapping = &#123; 'AmericanTypewriter': 'American Typewriter', 'AmericanTypewriter-Bold': 'American Typewriter', &#125;; static const _fontWeightMapping = &#123; 'AmericanTypewriter-Bold': FontWeight.bold, &#125;;&#125; 我花了些反复试验才得知Flutter需要在字体系列名称中留一个空格。因此，我创建了一些简单的映射表，可以扩展更多的条目。 Sketch还仅在字体名称中编码字体粗细，因此我也必须对此进行映射。但是屏幕显示几乎正确： 绘制形状要在第二个屏幕上绘制后退按钮形状，我需要解码ShapePath类的points属性。对于这一概念验证，我不必理会样条曲线或贝塞尔曲线，而只是简单的矢量。 查看JSON，我发现很奇怪的是，点实际上是由包含花括号的字符串表示的。不管怎样，这里有一些代码来渲染线条： 12345678910111213141516171819202122232425262728293031323334353637383940414243class ShapePath extends Element &#123; ShapePath(Map data) : super(data); bool get isClosed =&gt; data['isClosed']; Iterable&lt;CurvePoint&gt; get points =&gt; (data['points'] as List)?.map((p) =&gt; CurvePoint(p)) ?? []; @override void render(ui.Canvas canvas) &#123; final f = frame; var path = Path(); var first = true; for (final c in points) &#123; final pt = c.point; final x = f.left + pt.dx * f.width; final y = f.top + pt.dy * f.height; if (first) &#123; first = false; path.moveTo(x, y); &#125; else &#123; path.lineTo(x, y); &#125; &#125; if (isClosed) path.close(); final b = style.borders.first; canvas.drawPath( path, Paint() ..color = b.color ..strokeWidth = b.thickness ..style = PaintingStyle.stroke); &#125;&#125;class CurvePoint &#123; final Map data; CurvePoint(this.data) : assert(data['_class'] == 'curvePoint'); ui.Offset get point =&gt; _decode(data['point']); static ui.Offset _decode(String s) &#123; final parts = s.substring(1, s.length - 1).split(','); return ui.Offset( double.parse(parts[0]), double.parse(parts[1]), ); &#125;&#125; 在使Group不再显示其矩形后，我成功了。 导航实现导航的最后一件事。搜索JSON将显示以下数据结构： 12345678910111213&quot;flow&quot;: &#123; &quot;_class&quot;: &quot;MSImmutableFlowConnection&quot;, &quot;do_objectID&quot;: &quot;45E1A3D8-591A-4D01-B04B-36B58CA4CE51&quot;, &quot;animationType&quot;: 0, &quot;destinationArtboardID&quot;: &quot;49F995AB-4992-42AB-B708-86C5C42B3CDB&quot;&#125;,...&quot;flow&quot;: &#123; &quot;_class&quot;: &quot;MSImmutableFlowConnection&quot;, &quot;do_objectID&quot;: &quot;84BEAFDE-FFCE-42E5-8614-1AFC1FED8A19&quot;, &quot;animationType&quot;: 0, &quot;destinationArtboardID&quot;: &quot;back&quot;&#125;, 元素具有可选的Flow对象，该对象通过引用画板对象标识符或“魔术”字符串来定义目标。 Sketch支持多种动画（我使用默认动画，即“从右开始”）。 Dart Part这里是dart实现: 1234567class Flow &#123; final Map data; Flow(this.data) : assert(data['_class'] == 'MSImmutableFlowConnection'); String get destination =&gt; data['destinationArtboardID']; bool get isBack =&gt; destination == 'back';&#125; 然后在Element中添加get方法: 1234abstract class Element &#123; ... Flow get flow =&gt; data['flow'] != null ? Flow(data['flow']) : null;&#125; 在Sketch中，我将第一个画板标记为初始屏幕。因此，我在JSON中搜索了一个指标，最终找到了isFlowHome属性。让我们使用此属性查找要显示的初始画板，而不是对其名称进行硬编码： 123456789101112class Artboard extends Element &#123; ... bool get isFlowHome =&gt; data['isFlowHome'];&#125;class File &#123; ... Artboard get initialArtboard =&gt; artboards.values.firstWhere((a) =&gt; a.isFlowHome); Artboard artboardById(String id) =&gt; artboards.values.firstWhere((a) =&gt; a.id == id); ...&#125; Flutter Part为了实现导航，我使用GestureDetector来检测点击，然后使用上下文的渲染框计算相对于小部件的偏移量，然后在当前画板的层次结构中搜索被击中的元素。如果存在这样的元素并且它具有Flow对象，那么我将更改场景。 我重构MyApp一次加载Sketch文件： 123456789101112131415161718192021class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: FutureBuilder&lt;sk.File&gt;( future: _load(context), builder: (context, snapshot) &#123; if (!snapshot.hasData) return LoadingPage(); final file = snapshot.data; return SketchPage(file, file.initialArtboard); &#125;, ), ); &#125; Future&lt;sk.File&gt; _load(BuildContext context) &#123; final bundle = DefaultAssetBundle.of(context); return bundle.load('example.sketch').then((asset) &#123; return sk.File(asset.buffer.asUint8List()); &#125;); &#125;&#125; 您可以根据需要选择此LoadingPage： 12345678class LoadingPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center(child: CircularProgressIndicator()), ); &#125;&#125; 新的SketchPage处理导航，并将其他所有内容委托给SketchArtboard小部件。 1234567891011121314151617181920212223242526272829class SketchPage extends StatelessWidget &#123; SketchPage(this.file, this.artboard); final sk.File file; final sk.Artboard artboard; @override Widget build(BuildContext context) &#123; return Scaffold( body: Artboard( onPressed: (flow) =&gt; _navigate(context, flow), artboard: artboard, ), ); &#125; void _navigate(BuildContext context, sk.Flow flow) &#123; if (flow.isBack) &#123; Navigator.pop(context); &#125; else &#123; Navigator.push( context, MaterialPageRoute( builder: (_) =&gt; SketchPage( file, file.artboardById(flow.destination), ), ), ); &#125; &#125;&#125; 这是新的Artboard小部件，该小部件可检测手势并在Element中使用命中测试算法来查找被点击的元素并返回其流程对象（如果有）。 123456789101112131415161718192021222324class Artboard extends StatelessWidget &#123; const Artboard(&#123; Key key, @required this.onPressed, @required this.artboard, &#125;) : super(key: key); final ValueChanged&lt;sk.Flow&gt; onPressed; final sk.Artboard artboard; @override build(BuildContext context) &#123; return GestureDetector( onTapUp: (details) &#123; RenderBox box = context.findRenderObject(); final offset = box.globalToLocal(details.globalPosition); final flow = artboard.hit(offset); if (flow != null) onPressed(flow); &#125;, child: CustomPaint( size: artboard.frame.size, painter: ArtboardPainter(artboard), ), ); &#125;&#125; 这是Element的hit方法： 123456789101112abstract class Element &#123; ... Flow hit(ui.Offset offset) &#123; if (!frame.contains(offset)) return null; final localOffset = offset - frame.topLeft; for (final child in layers) &#123; final flow = child.hit(localOffset); if (flow != null) return flow; &#125; return flow; &#125;&#125; 这是难题的最后一部分。我可以在通过（简单）Sketch画板创建的多个SketchPage小部件之间导航。我很自豪地展示了最终应用的动画： 结语当然，还有很多东西不见了。 Sketch具有更多基本元素，可以进行变换，可以将它们分组并重新用作符号，其中包括复杂的路径，渐变，阴影等等。然后，面临将UI缩放到其他屏幕尺寸的挑战。但是，希望如此。 将Sketch设计转换为真正的Flutter小部件（如按钮和输入字段）也将非常有趣。但是，这将需要与Flutter正常工作方式截然不同的布局，因此，我没有遵循这条路线。 如果您对源代码或添加更多功能有帮助，请在下面发表评论，我们很乐意将其公开。感谢您阅读本文，也请查看我的其他文章。 原文：Creating a Flutter App from Sketch]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter、Sketch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView菜单全屏解决方案]]></title>
    <url>%2F2019%2F02%2F01%2Frecyclerview-menu%2F</url>
    <content type="text"><![CDATA[前言目前菜单界面采用RecyclerView + GridLayoutManager实现，最大的好处是修改样式十分方便。但是GridLayoutManager只能在单方向撑满屏幕，如果在有限个item内横向竖向都撑满该怎么做呢？ 解决方案如果是菜单全屏，那么意味着当前界面展示了所有itemView，完全可以抛开缓存机制模仿GridLayoutManager重新写一个LayoutManager。但总觉得还是太麻烦，那就动态计算itemView的高度吧（以下均针对GridLayoutManager横向情况）。 创建一个Adapter，我们重点关注onBindViewHolder函数：12345678910111213141516171819202122var data = emptyList&lt;String&gt;() set(value) &#123; field = value notifyDataSetChanged() &#125;private var itemHeight = 0fun updateItemHeight(height: Int) &#123; itemHeight = height&#125;override fun onBindViewHolder(holder: MenuViewHolder, position: Int) &#123; val s = data[position] holder.tvTitle.text = s val layoutParams = holder.itemView.layoutParams // 高度可能有盈余，减1保证不可滑动 layoutParams.height = itemHeight - 1&#125; 在onBindViewHolder函数中，获取到layoutParams，并给height撑满界面时所需的高度即可。再看一下Activity中计算itemHeight的方法，也十分简单：123456789private fun measureHeight(): Int &#123; val row: Int = if (0 == menuData.size % gridLayoutManager.spanCount) &#123; menuData.size / gridLayoutManager.spanCount &#125; else &#123; menuData.size / gridLayoutManager.spanCount + 1 &#125; return recyclerView.height / row&#125; 如果item的个数能整除列数，意味着正好撑满最后一行，因此行数为menuData.size / gridLayoutManager.spanCount；如果不能整除就加1。之后设置一下Adapter。1234567btAdd.setOnClickListener &#123; menuData.add("第$&#123;count++&#125;项") menuAdapter.run &#123; data = menuData updateItemHeight(measureHeight()) &#125;&#125; 最后看一下效果图：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android批量引用资源文件]]></title>
    <url>%2F2018%2F11%2F05%2Fandroid-resource-get%2F</url>
    <content type="text"><![CDATA[每次和同事吃饭的时候都会因为不知道吃什么而纠结好久，于是自己做了个小应用帮忙做选择。由于应用功能过于简单，想着加点好玩的东西上去，这时候，问题来了。 问题应用通过随机一个position，让RecyclerView滑动到某个餐馆的位置，我要做的是在每个RecyclerView的item上依次加gif每一帧的图片，达到一个逐帧动画的效果。由于图片放在资源文件中（50张），这意味着我要手动添加50张图片文件资源的id于一个list，这也太麻烦了，我肯定不会干。 解决方案等我累死累活50个添加完，我脑海中出现了某个想法：平时我们获取状态栏的高度是怎么获取的？12345var result = 0val resourceId = resources.getIdentifier("status_bar_height", "dimen", "android")if (resourceId &gt; 0) &#123; result = resources.getDimensionPixelSize(resourceId)&#125; 这个getIdentifier函数就有说法了。123public int getIdentifier(String name, String defType, String defPackage) &#123; return mResourcesImpl.getIdentifier(name, defType, defPackage);&#125; 源码的解释是”Return a resource identifier for the given resource name”，大意是给一个资源的名字，会返回该资源的id。我们看一下入参：name(资源名称)、defType(资源类型)以及defPackage(包名)。我们按此方法获取一下图片资源的id，看和R.xxx.xxx的方式获取的值是否一致。123Log.d(TAG, "通过R文件获取 -&gt; $&#123;R.drawable.man1&#125;")val resourceId = resources.getIdentifier("man1", "drawable", "com.yxd.thatdice")Log.d(TAG, "通过getIdentifier获取 -&gt; $resourceId") 诶，一致的，那就好办了，我们可以通过如下方式去获取一个资源文件的list(图片以man1.png，man2.png…的方式命名):1234567891011121314private const val DRAWABLE_TYPE = "drawable"private const val PACKAGE_NAME = "com.yxd.thatdice"fun getManList(context: Context): List&lt;Int&gt; &#123; val manList = ArrayList&lt;Int&gt;(50) for (i in 1..50) &#123; manList.add(getResourceId(context, "man$i")) &#125; return manList&#125;fun getResourceId(context: Context, name: String): Int &#123; return context.resources.getIdentifier(name, DRAWABLE_TYPE, PACKAGE_NAME)&#125; 最后看一下效果，录制的时候有丢帧，就着看了:至于效率问题，我也不敢说这种动态获取的方式一定会比直接从R文件读取低，或者低多少，这个还有待深入研究。至少从50张图片的量来看，可忽略不计。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL中的方法名陷阱]]></title>
    <url>%2F2018%2F08%2F17%2Faidl-methodname-trap%2F</url>
    <content type="text"><![CDATA[前些日子在调试AIDL时出现了客户端与服务端方法调用不一致的情况。由于之前AIDL开发经验不足，这个问题还是折腾了一会儿，在此记录。 场景重现在客户端和服务端创建相同的AIDL文件，并且定义两个方法A和B，均返回String以做测试:123456interface IMyAidlInterface &#123; String methodA(); String methodB();&#125; 服务端的实现如下:1234567891011121314@Overridepublic IBinder onBind(Intent intent) &#123; return new IMyAidlInterface.Stub() &#123; @Override public String methodA() throws RemoteException &#123; return "method A from service"; &#125; @Override public String methodB() throws RemoteException &#123; return "method B from service"; &#125; &#125;;&#125; 客户端调用如下:12345678910111213141516171819202122232425262728293031private IMyAidlInterface mInterface;private final ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mInterface = IMyAidlInterface.Stub.asInterface(iBinder); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; mInterface = null; &#125;&#125;;public void performA(View view) &#123; try &#123; final String resultA = mInterface.methodA(); Log.d(TAG, "执行A -&gt; " + resultA); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125;&#125;public void performB(View view) &#123; try &#123; final String resultB = mInterface.methodB(); Log.d(TAG, "执行B -&gt; " + resultB); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125;&#125; 依次执行方法A和B，日志如下:没问题，按预期的结果返回了。后来由于业务的变动，在服务端的AIDL中增加了测试方法，客户端不变:123456789101112131415161718192021222324252627282930// 服务端AIDLinterface IMyAidlInterface &#123; String test(); String methodA(); String methodB();&#125;// 服务端实现@Overridepublic IBinder onBind(Intent intent) &#123; return new IMyAidlInterface.Stub() &#123; @Override public String test() throws RemoteException &#123; return "test from service"; &#125; @Override public String methodA() throws RemoteException &#123; return "method A from service"; &#125; @Override public String methodB() throws RemoteException &#123; return "method B from service"; &#125; &#125;;&#125; 此时在客户端依次执行方法A和B，发现结果竟变成了这样:客户端调用methodA()，服务端执行了test()；客户端调用methodB()，服务端执行了methodA()，服务端竟然没有按客户端调用的方法名执行，而是按顺序执行的。 原因探究我们先看一下AIDL调用过程（底层暂且不表），以上述正常情况的调用为例。mInterface通过IMyAidlInterface.Stub的asInterface方法得到:1mInterface = IMyAidlInterface.Stub.asInterface(iBinder); 入参类型为IBinder，由于上述的客户端和服务端为两个应用不在一个进程，iBinder为远端service中的Binder代理(即BinderProxy)。看一下asInterface方法:12345678910public static com.robog.aidldemo.IMyAidlInterface asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.robog.aidldemo.IMyAidlInterface))) &#123; return ((com.robog.aidldemo.IMyAidlInterface) iin); &#125; return new com.robog.aidldemo.IMyAidlInterface.Stub.Proxy(obj);&#125; 如果同进程直接返回IInterface，即当前的Stub对象。不在一个进程返回的是IMyAidlInterface.Stub.Proxy(obj)。看一下静态内部类Proxy的构造方法:12345private android.os.IBinder mRemote;Proxy(android.os.IBinder remote) &#123; mRemote = remote;&#125; 接着执行mInterface.methodA()，即调用Proxy的methodA方法:12345678910111213141516@Overridepublic java.lang.String methodA() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_methodA, _data, _reply, 0); _reply.readException(); _result = _reply.readString(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 实际上调用了mRemote(BinderProxy)的transact方法:123456789101112131415161718192021222324252627public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; Binder.checkParcel(this, code, data, "Unreasonably large binder buffer"); if (mWarnOnBlocking &amp;&amp; ((flags &amp; FLAG_ONEWAY) == 0)) &#123; // For now, avoid spamming the log by disabling after we've logged // about this interface at least once mWarnOnBlocking = false; Log.w(Binder.TAG, "Outgoing transactions from this process must be FLAG_ONEWAY", new Throwable()); &#125; final boolean tracingEnabled = Binder.isTracingEnabled(); if (tracingEnabled) &#123; final Throwable tr = new Throwable(); Binder.getTransactionTracker().addTrace(tr); StackTraceElement stackTraceElement = tr.getStackTrace()[1]; Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, stackTraceElement.getClassName() + "." + stackTraceElement.getMethodName()); &#125; try &#123; return transactNative(code, data, reply, flags); &#125; finally &#123; if (tracingEnabled) &#123; Trace.traceEnd(Trace.TRACE_TAG_ALWAYS); &#125; &#125;&#125; 通过调用native方法transactNative经过Framework以及Kernel层(有兴趣的同学可以参考这篇文章)，最后调用到service端onTransact方法的返回后才会执行结束。我们看一下service端IMyAidlInterface.Stub()中onTransact的实现:123456789101112131415161718192021222324@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_methodA: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.methodA(); reply.writeNoException(); reply.writeString(_result); return true; &#125; case TRANSACTION_methodB: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.methodB(); reply.writeNoException(); reply.writeString(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 可以看到，onTransact方法中会根据code值执行相应的方法，这些方法即为IMyAidlInterface.Stub()中实现的方法。总结一下流程(省略底层):现在我们知道服务端会根据code值决定执行哪个方法，我们回过头看一下客户端传的code值:123// int FIRST_CALL_TRANSACTION = 0x00000001static final int TRANSACTION_methodA = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);static final int TRANSACTION_methodB = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); 该code值根据方法顺序依次加1，查看文件可以发现服务端的code值与之一致，此时方法调用没有问题。再看一下服务AIDL文件中新增test方法后的code值:123static final int TRANSACTION_test = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);static final int TRANSACTION_methodA = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);static final int TRANSACTION_methodB = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); 此时客户端如果调用methodA(客户端code值为1)，服务端会调用code值为1的方法，即test方法。 总结 谷歌为Android的跨进程通讯设计了Binder机制，并提供了一套傻瓜式的接口（AIDL接口）让我们方便使用。AIDL的作用是为了简化代码的书写，如果不嫌麻烦我们完全可以抛弃AIDL，自己用代码实现。 Binder本身能读懂的是为int类型的code而非方法名，AIDL接口中的方法名申明只是为了我们方便使用，在内部会把这些接口请求翻译成Binder明白的请求。 如果为了测试需要在服务端增加方法，为了不影响客户端调用，方法最好加在最后。当然，尽量保持客户端与服务端的AIDL文件的一致性。 我们知道transact方法会等待onTransact方法返回后才会结束(onTransact方法一般在Binder_n线程中执行)。因此，客户端最好在线程中调用AIDL方法，不然一旦服务端的实现比较耗时不仅会影响体验，更可能会导致ANR。 参考 彻底理解Android Binder通信架构 一篇文章了解相见恨晚的 Android Binder 进程间通讯机制]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造一个可定制的Path动画]]></title>
    <url>%2F2018%2F07%2F15%2Fsimple-line-view%2F</url>
    <content type="text"><![CDATA[前言创建这个库并非是由于某个需求，而是以前在阅读OkHttp源码时深感设计的精妙，一直有一个模仿其责任链模式做一个自定义View(SimpleLineView)的想法，一是为了好玩，二是希望能够抛砖引玉。 对于View的path动画，PathAnimView甚至是Lottie等都可以作出十分复杂酷炫的path动画。如果你的动画很复杂很酷炫，这个库可能就不太适合了。 当然，SimpleLineView也有自己的优势：1、可随意定制路径2、路径可以随意组合3、支持progress 效果图 整体架构1、自定义Painter（绘制相关接口），提供绘制功能。2、RealChain实现了Chain接口并且维护了一个Painter的list，控制所有Painter依次执行绘制。3、SimpleLineView维护了一个RealChain并且对外提供了方法，用于添加Painter以及控制动画的启动、停止和继续。在onDraw里调用当前Painter的onDraw方法实现真正的绘制。 使用1234567891011121314// 圆形PixelPath circlePath = new PixelPath(10, 10, new int[]&#123;1, 100&#125;);CirclePainter ciclePainter = new RealCirclePainter(circlePath, 1000, -120, 360, false);// 矩形PixelPath squarePath = new PixelPath(2, 2, new int[]&#123;1, 2, 4, 3&#125;);Painter squarePainter = new SegmentPainter(squarePath, 1000, true);// 添加路径mView.addPainter(ciclePainter).addPainter(squarePainter);// 启动mView.start();// 停止mView.stop();// 继续mView.stick(); 前期准备：PixelPath1234567// 横向像素private int mHorizontal;// 纵向像素private int mVertical;// 路径经过的像素序号private int[] mPath;SimpleLineView将View的长和宽分成若干个格子，格子数由图片的像素决定，并且规定了path的序号（从1开始，从左往右、从上到下依次递增1）。 例如，一张像素为4 * 4的图片 这里的mHorizontal(横向格子数)和mVertical(纵向格子数)都为4。如果mPath为{1, 13, 16, 4}, 则绘制的图形为依次连接1，13，16，4的矩形(是否封闭可设置对应参数)。如果图形的形状比较复杂，可以用PS打开图片，依次获取像素点的x和y值(这里x和y值的单位可以是像素、厘米等，但是计算时要与图像大小的单位一致)。假设图像宽为w, 高为h, 则当前点的值为 w * ( y - 1) + x。 Painter接口Painter接口主要提供了绘制的功能以及绘制时所需要的一些参数。12345678910111213141516171819202122public interface Painter &#123; // 获取Path PixelPath getPixelPath(); // 时长 int duration(); // 路径是否闭合 boolean close(); // 设置Paint void setPaint(Paint paint); // 获取Paint Paint getPaint(); // 动画是否正在进行 boolean isRunning(); // 开始动画 void start(Chain chain, Action action); // 停止动画 void stop(); // 真正绘制的地方 void onDraw(Canvas canvas); // 进行下一笔绘画时，完整画完当前笔 void completeDraw(Canvas canvas);&#125; onDraw方法和View的onDraw方法一样实现绘制。这里主要介绍一下completeDraw方法。由于每个Painter是依次绘制的，当下一个Painter进行绘制时，当前Pianter的形状也需要绘制，所以这里的completeDraw应该是当前Painter所要绘制的完整形状。这个方法会被当前Painter之后的每一个Painter调用。有点绕，看一下抽象类AbstractPainter的onDraw实现：1234567@Overridepublic void onDraw(Canvas canvas) &#123; // 1.完成之前Painter的绘制 drawPreviouse(canvas); // 2.绘制当前 realDraw(canvas);&#125; drawPreviouse方法：12345678910111213141516/** * 开始当前绘制前，先完成之前的绘制 * @param canvas */private void drawPreviouse(Canvas canvas) &#123; if (chain != null) &#123; // 当前Painter的index final int index = chain.index(); final List&lt;Painter&gt; painters = chain.painters(); // 遍历所有之前的Painter，调用completeDraw方法 for (int i = 0; i &lt; index - 1; i ++) &#123; final Painter painter = painters.get(i); painter.completeDraw(canvas); &#125; &#125;&#125; 为了方便说明，看一下AbstractPainter的一个子类RealCirclePainter的completeDraw和realDraw方法：123456789@Overridepublic void completeDraw(Canvas canvas) &#123; canvas.drawArc(mRectF, mStartAngle, mSweepAngle, mUseCenter, paint);&#125;@Overrideprotected void realDraw(Canvas canvas) &#123; canvas.drawArc(mRectF, mStartAngle, angle(), mUseCenter, paint);&#125; mSweepAngle是所需扫过的角度，angle()为当前的角度大小，这个角度会随着时间递增，如此也就有了动画。当然必须得看一下AbstractPainter的start方法，这个才是每个Painter开始的地方。123456789101112131415@Overridepublic void start(Chain chain, Action action) &#123; //是否正在执行 mIsRunning = true; this.chain = chain; // 计算实际坐标点 pointList = action.fetchCoordinate(this); // 执行绘制 boolean isFinish = performDraw(action); mIsRunning = false; // 如果的确绘制完成，下一步 if (isFinish) &#123; chain.proceed(); &#125;&#125; fetchCoordinate方法为绘制提供了坐标点，实现下文会介绍。之后通过performDraw方法来开始View的绘制，看一下AbstractPainter另一个子类SegmentPainter的performDraw方法实现：12345678910111213141516171819202122@Overridepublic boolean performDraw(Action action) &#123; // 总路程 float distance = Utils.calDistance(pointList, close()); for (int i = 0; i &lt; pointList.size(); i++) &#123; // 省略若干代码 while (!current.isPathFinish()) &#123; if (!isRunning()) &#123; return false; &#125; // 省略计算代码 // 更新界面 action.update(this); SystemClock.sleep(INTERVAL); &#125; // 保证图像都绘制 action.update(this); &#125; return true;&#125; 在performDraw方法中会遍历PixelPoint的list，每隔INTERVAL时间调用Action接口的update方法更新View一次。 Chain接口Chain主要提供了调控的功能。1234567891011121314public interface Chain &#123; // 执行 void proceed(); // 当前Painter的index int index(); // 设置结束监听 void setOnFinishListener(OnFinishListener listener); // 所有的Painter List&lt;Painter&gt; painters(); // 结束接听接口 interface OnFinishListener &#123; void onFinish(int index); &#125;&#125; 看一下唯一实现类RealChain的proceed方法123456789101112131415161718192021222324@Overridepublic void proceed() &#123; if (mOnFinishListener != null &amp;&amp; mIndex &gt; 0) &#123; mOnFinishListener.onFinish(mIndex - 1); &#125; // 如果index等于size就返回结束了 if (mIndex == mPainters.size()) &#123; return; &#125; // 设置progress时会不断调用该方法，为了避免不断创建RealChain对象， // 这里用了SparseArray保存所有已经创建的RealChain对象，key为index Chain next = mChainPool.get(mIndex); if (next == null) &#123; next = new RealChain(mPainters, mIndex + 1, mAction); next.setOnFinishListener(mOnFinishListener); mChainPool.put(mIndex, next); &#125; final Painter painter = mPainters.get(mIndex); painter.start(next, mAction);&#125; 这里照搬了OkHttp，通过在RealChain的procced方法创建新的RealChain对象实现Painter的依次执行。由于Painter都是自定义的，所以当index等于所有Painter的size时return就好了，而OkHttp的最后一个Interceptor是没有创建Chain的。 Action接口Action接口主要提供了计算当前path实际坐标点、通知更新View以及设置或者获取View的所需的参数的功能，这也是View需要实现的接口。123456789101112131415161718192021222324252627282930313233public interface Action &#123; /** * 更新view，实际调用的是&#123;@link SimpleLineView#postInvalidate()&#125;方法 * @param painter 该painter实现view的onDraw */ void update(Painter painter); /** * 对外接口，设置progress后更新view * @param progress */ void setProgress(int progress); /** * painter中通过调用该接口进行相应的绘制工作 * @return */ int getProgress(); /** * 通过当前view执行的状态作出相应处理，可参考&#123;@link com.robog.library.painter.TaskPainter#start(Chain, Action)&#125;方法 * @return */ int getStatus(); /** * 获得当前painter下所有点的实际坐标 * @param painter * @return */ List&lt;PixelPoint&gt; fetchCoordinate(Painter painter);&#125; 看一下fetchCoordinate方法：1234567891011121314@Overridepublic List&lt;PixelPoint&gt; fetchCoordinate(Painter painter) &#123; // 同样的，这里避免频繁设置progress不断创建PixelPoint对象 List&lt;PixelPoint&gt; pixelPoints = mPointPool.get(painter); if (pixelPoints != null) &#123; return pixelPoints; &#125; pixelPoints = new ArrayList&lt;&gt;(); Utils.setPoint(painter, pixelPoints, mWidth, mHeight); mPointPool.put(painter, pixelPoints); return pixelPoints;&#125; Utils的setPoint方法：1234567891011121314151617181920212223242526272829303132333435363738394041public static void setPoint(Painter painter, List&lt;PixelPoint&gt; pixelPoints, int width, int height) &#123; // 先获取PixelPath final PixelPath pixelPath = painter.getPixelPath(); final int[] path = pixelPath.getPath(); final int horizontal = pixelPath.getHorizontal(); final int vertical = pixelPath.getVertical(); for (int target : path) &#123; // 如果PixelPath中点的序号超过总数则抛出异常 if (target &gt; horizontal * vertical) &#123; throw new IllegalArgumentException("Current coordinate [" + target + "] is invalid!"); &#125; // 商 int quotient = target / horizontal; // 余数 int remainder = target % horizontal; // 实际的x和y坐标 float x; float y; // x和y坐标的系数 float coefficientX; float coefficientY; if (remainder != 0) &#123; // 余数不为0时，这里的0.5是让实际坐标点位于方格中心点 coefficientX = remainder - 0.5f; coefficientY = quotient + 0.5f; &#125; else &#123; // 余数为0时 coefficientX = horizontal - 0.5f; coefficientY = quotient - 0.5f; &#125; // width / horizontal为每个方格的宽度 // 每个方格的宽度乘系数即为x的坐标 x = coefficientX * width / horizontal; // 同理 y = coefficientY * height / vertical; PixelPoint pixelPoint = new PixelPoint(x, y); pixelPoints.add(pixelPoint); &#125;&#125; 用的小学数学，看一下注释就好了。接着看一下update和onDraw方法：1234567891011@Overridepublic void update(Painter painter) &#123; mCurrentPainter = painter; postInvalidate();&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; if (mCurrentPainter != null) &#123; mCurrentPainter.onDraw(canvas); &#125;&#125; 在update中设置当前的painter，由于之前的操作在线程中，这里调用postInvalidate通知绘制，在View的onDraw方法中调用Painter的onDraw实现绘制。 其他介绍完三个接口，整体的流程算是介绍完了，下面看一下两个功能型的Painter。 DelayPainter123456789101112@Overridepublic void start(Chain chain, Action action) &#123; try &#123; if (Looper.myLooper() == Looper.getMainLooper()) &#123; throw new RuntimeException("Can't delay in the main thread!"); &#125; Thread.sleep(mTime); chain.proceed(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 在start方法通过Thread.sleep进行延时，如果当前方法在主线程执行就抛出异常。 TaskPainter123456789101112131415@Overridepublic void start(final Chain chain, final Action action) &#123; mIsRunning = true; EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; // 当status为start时重置point if (action.getStatus() == STATUS_START) &#123; Utils.resetPointStatus(mPainterPool); &#125; chain.proceed(); mIsRunning = false; &#125; &#125;);&#125; 当Painter有多个时，计算会耗费一定的时间，这里将chain的procced置于线程中，让后续的过程都在线程中执行以保证动画的流畅。并且，当start动画时，将PixelPoint的状态重置，保证下一次绘制是一个完整的过程。 不足1、图形较为复杂时，通过PS获取计算坐标点较为繁琐。2、由于计算在子线程，绘制在主线程，当SimpleLineView设置progress过快时，上一步onDraw可能未完成，画面可能会闪动，暂时的解决方法是将此过程放入主线程。使用代码如下：12mView.addPainter(mCicleProgressPainter).addPainter(mHookProgressPainter).onMain();mView.setProgress(progress); OK，基本上介绍完了，如果有什么不足或者有什么问题欢迎指正！ 项目地址：https://github.com/XingdongYu/SimpleLineView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Android中的缓存(一)——内存缓存]]></title>
    <url>%2F2018%2F07%2F03%2Fandroid-cache-1%2F</url>
    <content type="text"><![CDATA[内存缓存一般通过Map、List、链表等集合实现。每次将新建的对象存入集合，下一次需要新建时直接从集合中去取，这样避免了每次新建对象带来的开销以及内存占用。 Map我们通过lifecycle包创建ViewModel时会通过这样的方式: 1ViewModelProviders.of(activity).get(MyViewModel.class); 看一下get方法:1234567891011121314151617181920212223public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels"); &#125; return get(DEFAULT_KEY + ":" + canonicalName, modelClass);&#125;public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; return (T) viewModel; &#125; else &#123; if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); return (T) viewModel;&#125; 可以看到，ViewModel是通过mViewModelStore.get(key)去获取的，key为DEFAULT_KEY + “:” + canonicalName。如果为空就新建一个，然后存入mViewModelStore。如果下一次需要新建相同的ViewModel类，直接从mViewModelStore取就好了。看一下mViewModelStore:1234567891011121314151617public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; // 省略&#125; ViewModelStore很简单，维护了一个HashMap，存储就是通过HashMap实现的，这也是我们常用的缓存策略。如果key为int，选用SparseArray更佳。之前写的库SimpleLineView中因为会频繁创建Point，用了HashMap缓存Point。 链表我们通常在创建Message时不会通过new关键字来创建，而是通过Message.obtain()。在看obtain方法之前我们先看一下Message中的recycleUnchecked方法:12345678910111213141516171819202122232425private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50;void recycleUnchecked() &#123; flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 我们知道每次Message处理完后，Looper会调用Message的recycleUnchecked方法来回收该Message对象。方法主要是将当前Message的参数重置，然后放入Message池——sPool(最多50个)。sPool为静态Message变量，将当前Message插到sPool所引用的Message对象前面，并且让sPool指向当前Message，如此就形成了一个缓存链。 再来看一下obtain方法:12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 如果sPool不为空，就返回sPool所引用的Message对象，并且让sPool指向它的next，即当前Message的下一个Message对象，即obtain方法下一次调用时所返回的对象。最近写的持久化日志库PersistentLog因为会频繁创建日志对象LogBean，参照Message写了缓存池。 List目前没想到例子，想起来了再补🐶]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F07%2F02%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[之前文章一直在cnblog上写，虽然不多却也花费了不少心思，所以会把这些文章陆续迁移过来。以后如果踩了什么坑或者有什么好玩的东西也都会放在这儿。希望能一直坚持下去。 2018.07.02by: RoboG]]></content>
  </entry>
</search>
