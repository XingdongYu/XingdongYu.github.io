<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈Android中的缓存(一)——内存缓存]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%B5%85%E8%B0%88Android%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%981%2F</url>
    <content type="text"><![CDATA[内存缓存一般通过Map、List、链表等集合实现。将已创建的对象放入集合中，等下次需要新建时，直接从集合中去取。如果集合中的对象已被回收，就重复上述步骤。这样避免了每次新建对象带来的开销以及内存占用。 一、Map我们通过lifecycle包创建ViewModel时会通过这样的方式: 1ViewModelProviders.of(activity).get(MyViewModel.class); 看一下get方法:1234567891011121314151617181920212223242526public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels"); &#125; return get(DEFAULT_KEY + ":" + canonicalName, modelClass);&#125;public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 可以看到，ViewModel是通过mViewModelStore.get(key)去获取的，key为DEFAULT_KEY + “:” + canonicalName。如果为空就新建一个，然后存入mViewModelStore。如果下一次需要新建同一个ViewModel类，直接从mViewModelStore取就好了。看一下mViewModelStore:1234567891011121314151617public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; // 省略&#125; ViewModelStore很简单，维护了一个HashMap。ViewModelStore存储就是通过HashMap实现的，这也是我们常用的缓存策略。如果key为int，选用SparseArray更佳。之前写的库SimpleLineView中因为会频繁创建Point，用了HashMap缓存Point。 二、链表我们通常在创建Message时不会通过new关键字来创建，而是通过Message.obtain()。在看obtain方法之前我们先看一下Message中的recycleUnchecked方法:12345678910111213141516171819202122232425private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50;void recycleUnchecked() &#123; flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 我们知道每次成功处理Message后，Looper会调用Message的recycleUnchecked方法用于回收Message。主要是将当前Message一些参数重置，然后放入Message池——sPool(最多50个)。sPool为静态Message变量，将当前Message插到sPool所引用的Message对象前面，并且让sPool指向当前Message。这样保证了Message链表头部的为最新对象。 再来看一下obtain方法:12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 如果sPool不为空，就返回sPool所引用的Message对象，并且让sPool指向它的next，即当前Message的下一个Message对象，即obtain方法下一次调用时所返回的对象。最近写的持久化日志库PersistentLog因为会频繁创建日志对象LogBean，参照Message写了缓存池。 三、List目前没想到例子，想起来了再补🐶]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F07%2F02%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[之前文章一直在cnblog上写，虽然不多却也花费了不少心思，所以会把这些文章陆续迁移过来。以后如果踩了什么坑或者有什么好玩的东西也都会放在这儿。希望能一直坚持下去。 2018.07.02by: RoboG]]></content>
  </entry>
</search>
