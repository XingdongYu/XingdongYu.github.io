<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[打造一个可定制的Path动画]]></title>
    <url>%2F2018%2F07%2F15%2Fsimple-line-view%2F</url>
    <content type="text"><![CDATA[前言创建这个库并非是由于某个需求，而是以前在阅读OkHttp源码时深感设计的精妙，一直有一个模仿其责任链模式做一个自定义View(SimpleLineView)的想法，一是为了好玩，二是希望能够抛砖引玉。 对于View的path动画，PathAnimView甚至是Lottie等都可以作出十分复杂酷炫的path动画。如果你的动画很复杂很酷炫，这个库可能就不太适合了。 当然，SimpleLineView也有自己的优势：1、可随意定制路径2、路径可以随意组合3、支持progress 效果图 整体架构1、自定义Painter（绘制相关接口），提供绘制功能。2、RealChain实现了Chain接口并且维护了一个Painter的list，控制所有Painter依次执行绘制。3、SimpleLineView维护了一个RealChain并且对外提供了方法，用于添加Painter以及控制动画的启动、停止和继续。在onDraw里调用当前Painter的onDraw方法实现真正的绘制。 使用1234567891011121314// 圆形PixelPath circlePath = new PixelPath(10, 10, new int[]&#123;1, 100&#125;);CirclePainter ciclePainter = new RealCirclePainter(circlePath, 1000, -120, 360, false);// 矩形PixelPath squarePath = new PixelPath(2, 2, new int[]&#123;1, 2, 4, 3&#125;);Painter squarePainter = new SegmentPainter(squarePath, 1000, true);// 添加路径mView.addPainter(ciclePainter).addPainter(squarePainter);// 启动mView.start();// 停止mView.stop();// 继续mView.stick(); 前期准备：PixelPath1234567// 横向像素private int mHorizontal;// 纵向像素private int mVertical;// 路径经过的像素序号private int[] mPath;SimpleLineView将View的长和宽分成若干个格子，格子数由图片的像素决定，并且规定了path的序号（从1开始，从左往右、从上到下依次递增1）。 例如，一张像素为4 * 4的图片 这里的mHorizontal(横向格子数)和mVertical(纵向格子数)都为4。如果mPath为{1, 13, 16, 4}, 则绘制的图形为依次连接1，13，16，4的矩形(是否封闭可设置对应参数)。如果图形的形状比较复杂，可以用PS打开图片，依次获取像素点的x和y值(这里x和y值的单位可以是像素、厘米等，但是计算时要与图像大小的单位一致)。假设图像宽为w, 高为h, 则当前点的值为 w * ( y - 1) + x。 Painter接口Painter接口主要提供了绘制的功能以及绘制时所需要的一些参数。12345678910111213141516171819202122public interface Painter &#123; // 获取Path PixelPath getPixelPath(); // 时长 int duration(); // 路径是否闭合 boolean close(); // 设置Paint void setPaint(Paint paint); // 获取Paint Paint getPaint(); // 动画是否正在进行 boolean isRunning(); // 开始动画 void start(Chain chain, Action action); // 停止动画 void stop(); // 真正绘制的地方 void onDraw(Canvas canvas); // 进行下一笔绘画时，完整画完当前笔 void completeDraw(Canvas canvas);&#125; onDraw方法和View的onDraw方法一样实现绘制。这里主要介绍一下completeDraw方法。由于每个Painter是依次绘制的，当下一个Painter进行绘制时，当前Pianter的形状也需要绘制，所以这里的completeDraw应该是当前Painter所要绘制的完整形状。这个方法会被当前Painter之后的每一个Painter调用。有点绕，看一下抽象类AbstractPainter的onDraw实现：1234567@Overridepublic void onDraw(Canvas canvas) &#123; // 1.完成之前Painter的绘制 drawPreviouse(canvas); // 2.绘制当前 realDraw(canvas);&#125; drawPreviouse方法：12345678910111213141516/** * 开始当前绘制前，先完成之前的绘制 * @param canvas */private void drawPreviouse(Canvas canvas) &#123; if (chain != null) &#123; // 当前Painter的index final int index = chain.index(); final List&lt;Painter&gt; painters = chain.painters(); // 遍历所有之前的Painter，调用completeDraw方法 for (int i = 0; i &lt; index - 1; i ++) &#123; final Painter painter = painters.get(i); painter.completeDraw(canvas); &#125; &#125;&#125; 为了方便说明，看一下AbstractPainter的一个子类RealCirclePainter的completeDraw和realDraw方法：123456789@Overridepublic void completeDraw(Canvas canvas) &#123; canvas.drawArc(mRectF, mStartAngle, mSweepAngle, mUseCenter, paint);&#125;@Overrideprotected void realDraw(Canvas canvas) &#123; canvas.drawArc(mRectF, mStartAngle, angle(), mUseCenter, paint);&#125; mSweepAngle是所需扫过的角度，angle()为当前的角度大小，这个角度会随着时间递增，如此也就有了动画。当然必须得看一下AbstractPainter的start方法，这个才是每个Painter开始的地方。123456789101112131415@Overridepublic void start(Chain chain, Action action) &#123; //是否正在执行 mIsRunning = true; this.chain = chain; // 计算实际坐标点 pointList = action.fetchCoordinate(this); // 执行绘制 boolean isFinish = performDraw(action); mIsRunning = false; // 如果的确绘制完成，下一步 if (isFinish) &#123; chain.proceed(); &#125;&#125; fetchCoordinate方法为绘制提供了坐标点，实现下文会介绍。之后通过performDraw方法来开始View的绘制，看一下AbstractPainter另一个子类SegmentPainter的performDraw方法实现：12345678910111213141516171819202122@Overridepublic boolean performDraw(Action action) &#123; // 总路程 float distance = Utils.calDistance(pointList, close()); for (int i = 0; i &lt; pointList.size(); i++) &#123; // 省略若干代码 while (!current.isPathFinish()) &#123; if (!isRunning()) &#123; return false; &#125; // 省略计算代码 // 更新界面 action.update(this); SystemClock.sleep(INTERVAL); &#125; // 保证图像都绘制 action.update(this); &#125; return true;&#125; 在performDraw方法中会遍历PixelPoint的list，每隔INTERVAL时间调用Action接口的update方法更新View一次。 Chain接口Chain主要提供了调控的功能。1234567891011121314public interface Chain &#123; // 执行 void proceed(); // 当前Painter的index int index(); // 设置结束监听 void setOnFinishListener(OnFinishListener listener); // 所有的Painter List&lt;Painter&gt; painters(); // 结束接听接口 interface OnFinishListener &#123; void onFinish(int index); &#125;&#125; 看一下唯一实现类RealChain的proceed方法123456789101112131415161718192021222324@Overridepublic void proceed() &#123; if (mOnFinishListener != null &amp;&amp; mIndex &gt; 0) &#123; mOnFinishListener.onFinish(mIndex - 1); &#125; // 如果index等于size就返回结束了 if (mIndex == mPainters.size()) &#123; return; &#125; // 设置progress时会不断调用该方法，为了避免不断创建RealChain对象， // 这里用了SparseArray保存所有已经创建的RealChain对象，key为index Chain next = mChainPool.get(mIndex); if (next == null) &#123; next = new RealChain(mPainters, mIndex + 1, mAction); next.setOnFinishListener(mOnFinishListener); mChainPool.put(mIndex, next); &#125; final Painter painter = mPainters.get(mIndex); painter.start(next, mAction);&#125; 这里照搬了OkHttp，通过在RealChain的procced方法创建新的RealChain对象实现Painter的依次执行。由于Painter都是自定义的，所以当index等于所有Painter的size时return就好了，而OkHttp的最后一个Interceptor是没有创建Chain的。 Action接口Action接口主要提供了计算当前path实际坐标点、通知更新View以及设置或者获取View的所需的参数的功能，这也是View需要实现的接口。123456789101112131415161718192021222324252627282930313233public interface Action &#123; /** * 更新view，实际调用的是&#123;@link SimpleLineView#postInvalidate()&#125;方法 * @param painter 该painter实现view的onDraw */ void update(Painter painter); /** * 对外接口，设置progress后更新view * @param progress */ void setProgress(int progress); /** * painter中通过调用该接口进行相应的绘制工作 * @return */ int getProgress(); /** * 通过当前view执行的状态作出相应处理，可参考&#123;@link com.robog.library.painter.TaskPainter#start(Chain, Action)&#125;方法 * @return */ int getStatus(); /** * 获得当前painter下所有点的实际坐标 * @param painter * @return */ List&lt;PixelPoint&gt; fetchCoordinate(Painter painter);&#125; 看一下fetchCoordinate方法：1234567891011121314@Overridepublic List&lt;PixelPoint&gt; fetchCoordinate(Painter painter) &#123; // 同样的，这里避免频繁设置progress不断创建PixelPoint对象 List&lt;PixelPoint&gt; pixelPoints = mPointPool.get(painter); if (pixelPoints != null) &#123; return pixelPoints; &#125; pixelPoints = new ArrayList&lt;&gt;(); Utils.setPoint(painter, pixelPoints, mWidth, mHeight); mPointPool.put(painter, pixelPoints); return pixelPoints;&#125; Utils的setPoint方法：1234567891011121314151617181920212223242526272829303132333435363738394041public static void setPoint(Painter painter, List&lt;PixelPoint&gt; pixelPoints, int width, int height) &#123; // 先获取PixelPath final PixelPath pixelPath = painter.getPixelPath(); final int[] path = pixelPath.getPath(); final int horizontal = pixelPath.getHorizontal(); final int vertical = pixelPath.getVertical(); for (int target : path) &#123; // 如果PixelPath中点的序号超过总数则抛出异常 if (target &gt; horizontal * vertical) &#123; throw new IllegalArgumentException("Current coordinate [" + target + "] is invalid!"); &#125; // 商 int quotient = target / horizontal; // 余数 int remainder = target % horizontal; // 实际的x和y坐标 float x; float y; // x和y坐标的系数 float coefficientX; float coefficientY; if (remainder != 0) &#123; // 余数不为0时，这里的0.5是让实际坐标点位于方格中心点 coefficientX = remainder - 0.5f; coefficientY = quotient + 0.5f; &#125; else &#123; // 余数为0时 coefficientX = horizontal - 0.5f; coefficientY = quotient - 0.5f; &#125; // width / horizontal为每个方格的宽度 // 每个方格的宽度乘系数即为x的坐标 x = coefficientX * width / horizontal; // 同理 y = coefficientY * height / vertical; PixelPoint pixelPoint = new PixelPoint(x, y); pixelPoints.add(pixelPoint); &#125;&#125; 用的小学数学，看一下注释就好了。接着看一下update和onDraw方法：1234567891011@Overridepublic void update(Painter painter) &#123; mCurrentPainter = painter; postInvalidate();&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; if (mCurrentPainter != null) &#123; mCurrentPainter.onDraw(canvas); &#125;&#125; 在update中设置当前的painter，由于之前的操作在线程中，这里调用postInvalidate通知绘制，在View的onDraw方法中调用Painter的onDraw实现绘制。 其他介绍完三个接口，整体的流程算是介绍完了，下面看一下两个功能型的Painter。 DelayPainter123456789101112@Overridepublic void start(Chain chain, Action action) &#123; try &#123; if (Looper.myLooper() == Looper.getMainLooper()) &#123; throw new RuntimeException("Can't delay in the main thread!"); &#125; Thread.sleep(mTime); chain.proceed(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 在start方法通过Thread.sleep进行延时，如果当前方法在主线程执行就抛出异常。 TaskPainter123456789101112131415@Overridepublic void start(final Chain chain, final Action action) &#123; mIsRunning = true; EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; // 当status为start时重置point if (action.getStatus() == STATUS_START) &#123; Utils.resetPointStatus(mPainterPool); &#125; chain.proceed(); mIsRunning = false; &#125; &#125;);&#125; 当Painter有多个时，计算会耗费一定的时间，这里将chain的procced置于线程中，让后续的过程都在线程中执行以保证动画的流畅。并且，当start动画时，将PixelPoint的状态重置，保证下一次绘制是一个完整的过程。 不足1、图形较为复杂时，通过PS获取计算坐标点较为繁琐。2、由于计算在子线程，绘制在主线程，当SimpleLineView设置progress过快时，上一步onDraw可能未完成，画面可能会闪动，暂时的解决方法是将此过程放入主线程。使用代码如下：12mView.addPainter(mCicleProgressPainter).addPainter(mHookProgressPainter).onMain();mView.setProgress(progress); OK，基本上介绍完了，如果有什么不足或者有什么问题欢迎指正！ 项目地址：https://github.com/XingdongYu/SimpleLineView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Android中的缓存(一)——内存缓存]]></title>
    <url>%2F2018%2F07%2F03%2Fandroid-cache-1%2F</url>
    <content type="text"><![CDATA[内存缓存一般通过Map、List、链表等集合实现。每次将新建的对象存入集合，下一次需要新建时直接从集合中去取，这样避免了每次新建对象带来的开销以及内存占用。 Map我们通过lifecycle包创建ViewModel时会通过这样的方式: 1ViewModelProviders.of(activity).get(MyViewModel.class); 看一下get方法:1234567891011121314151617181920212223public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels"); &#125; return get(DEFAULT_KEY + ":" + canonicalName, modelClass);&#125;public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; return (T) viewModel; &#125; else &#123; if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); return (T) viewModel;&#125; 可以看到，ViewModel是通过mViewModelStore.get(key)去获取的，key为DEFAULT_KEY + “:” + canonicalName。如果为空就新建一个，然后存入mViewModelStore。如果下一次需要新建相同的ViewModel类，直接从mViewModelStore取就好了。看一下mViewModelStore:1234567891011121314151617public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; // 省略&#125; ViewModelStore很简单，维护了一个HashMap，存储就是通过HashMap实现的，这也是我们常用的缓存策略。如果key为int，选用SparseArray更佳。之前写的库SimpleLineView中因为会频繁创建Point，用了HashMap缓存Point。 链表我们通常在创建Message时不会通过new关键字来创建，而是通过Message.obtain()。在看obtain方法之前我们先看一下Message中的recycleUnchecked方法:12345678910111213141516171819202122232425private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50;void recycleUnchecked() &#123; flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 我们知道每次Message处理完后，Looper会调用Message的recycleUnchecked方法来回收该Message对象。方法主要是将当前Message的参数重置，然后放入Message池——sPool(最多50个)。sPool为静态Message变量，将当前Message插到sPool所引用的Message对象前面，并且让sPool指向当前Message，如此就形成了一个缓存链。 再来看一下obtain方法:12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 如果sPool不为空，就返回sPool所引用的Message对象，并且让sPool指向它的next，即当前Message的下一个Message对象，即obtain方法下一次调用时所返回的对象。最近写的持久化日志库PersistentLog因为会频繁创建日志对象LogBean，参照Message写了缓存池。 List目前没想到例子，想起来了再补🐶]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F07%2F02%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[之前文章一直在cnblog上写，虽然不多却也花费了不少心思，所以会把这些文章陆续迁移过来。以后如果踩了什么坑或者有什么好玩的东西也都会放在这儿。希望能一直坚持下去。 2018.07.02by: RoboG]]></content>
  </entry>
</search>
